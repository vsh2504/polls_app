from django.urls import path

from . import views
app_name = 'polls'  #namespaces used to avoid same url names

#FUNCTION BASED VIEWS

# urlpatterns = [
#     # ex: /polls/
#     path('', views.index, name='index'),
#     # ex: /polls/5/
#     path('<int:question_id>/', views.detail, name='detail'),
#     # ex: /polls/5/results/
#     path('<int:question_id>/results/', views.results, name='results'),
#     # ex: /polls/5/vote/
#     path('<int:question_id>/vote/', views.vote, name='vote'),
# ]

#CLASS BASED VIEWS

#changed from <question_id> to <pk>.
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
    path('resultsdata/<int:question_id>/',views.resultsData,name='results-data'),
    # path('mymap/',views.myMap,name='my-map'),
]


"""
IMPROVEMENTS

We ought to add a similar get_queryset method to ResultsView and create
a new test class for that view. It’ll be very similar to what we have
just created; in fact there will be a lot of repetition.

We could also improve our application in other ways, adding tests along
the way. For example, it’s silly that Questions can be published on
the site that have no Choices. So, our views could check for this,
and exclude such Questions. Our tests would create a Question
without Choices and then test that it’s not published,
as well as create a similar Question with Choices, and test that it is
published.

Perhaps logged-in admin users should be allowed to see unpublished
Questions, but not ordinary visitors. Again: whatever needs to be
added to the software to accomplish this should be accompanied by a
test, whether you write the test first and then make the code pass the
test, or work out the logic in your code first and then write a test
to prove it.

"""

'''
STATIC FILES

Aside from the HTML generated by the server, web applications generally
need to serve additional files — such as images, JavaScript, or CSS —
necessary to render the complete web page. In Django, we refer to these
files as “static files”.
'''
